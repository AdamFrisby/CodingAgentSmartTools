using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using ModelContextProtocol.Protocol;
using ModelContextProtocol.Server;
using Cast.Tool.Commands;
using Spectre.Console.Cli;
using System.Reflection;
using System.Text.Json;

namespace Cast.Tool.McpServer;

public class CastMcpServer
{
    private readonly ILogger<CastMcpServer> _logger;
    private readonly Dictionary<string, (Type CommandType, string Description)> _commands;

    public CastMcpServer(ILogger<CastMcpServer> logger)
    {
        _logger = logger;
        _commands = DiscoverCastCommands();
    }

    private Dictionary<string, (Type CommandType, string Description)> DiscoverCastCommands()
    {
        var commands = new Dictionary<string, (Type CommandType, string Description)>();
        
        // Get all command types from the Cast.Tool assembly
        var castAssembly = typeof(RenameCommand).Assembly;
        var commandTypes = castAssembly.GetTypes()
            .Where(t => t.Namespace == "Cast.Tool.Commands" && 
                       t.Name.EndsWith("Command") && 
                       !t.IsAbstract)
            .ToList();

        _logger.LogInformation($"Found {commandTypes.Count} Cast commands");

        foreach (var commandType in commandTypes)
        {
            // Convert command type name to command name (e.g., RenameCommand -> rename)
            var commandName = ConvertTypeNameToCommandName(commandType.Name);
            var description = GetCommandDescription(commandType, commandName);
            
            commands[commandName] = (commandType, description);
            _logger.LogDebug($"Registered command: {commandName} -> {commandType.Name}");
        }

        return commands;
    }

    private string ConvertTypeNameToCommandName(string typeName)
    {
        // Remove "Command" suffix and convert PascalCase to kebab-case
        var name = typeName.Replace("Command", "");
        
        // Convert PascalCase to kebab-case
        var result = "";
        for (int i = 0; i < name.Length; i++)
        {
            if (i > 0 && char.IsUpper(name[i]))
            {
                result += "-";
            }
            result += char.ToLower(name[i]);
        }
        
        return result;
    }

    private string GetCommandDescription(Type commandType, string commandName)
    {
        // Try to get description from the command registration in Program.cs
        // For now, provide basic descriptions based on command names
        return commandName switch
        {
            "rename" => "Rename a symbol at the specified location",
            "extract-method" => "Extract a method from the selected code",
            "add-using" => "Add missing using statements",
            "convert-auto-property" => "Convert between auto property and full property",
            "add-explicit-cast" => "Add explicit cast to an expression",
            _ => $"C# refactoring command: {commandName}"
        };
    }

    public async Task<ListToolsResult> HandleListToolsAsync(ListToolsRequestParams request)
    {
        _logger.LogInformation("Handling list tools request");
        
        var tools = _commands.Select(kvp => new Tool
        {
            Name = $"cast_{kvp.Key.Replace("-", "_")}",
            Description = kvp.Value.Description,
            InputSchema = CreateToolInputSchema(kvp.Key, kvp.Value.CommandType)
        }).ToList();

        return new ListToolsResult { Tools = tools };
    }

    public async Task<CallToolResult> HandleCallToolAsync(CallToolRequestParams request)
    {
        _logger.LogInformation($"Handling call tool request for: {request.Name}");
        
        try
        {
            // Extract command name from tool name (remove "cast_" prefix and convert back)
            var commandName = request.Name.StartsWith("cast_") 
                ? request.Name.Substring(5).Replace("_", "-")
                : request.Name;

            if (!_commands.TryGetValue(commandName, out var commandInfo))
            {
                return new CallToolResult
                {
                    Content = [new TextContentBlock { Text = $"Unknown command: {commandName}" }],
                    IsError = true
                };
            }

            // Execute the Cast command
            var result = await ExecuteCastCommandAsync(commandName, commandInfo.CommandType, request.Arguments);
            
            return new CallToolResult
            {
                Content = [new TextContentBlock { Text = result }],
                IsError = false
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error executing Cast command");
            return new CallToolResult
            {
                Content = [new TextContentBlock { Text = $"Error: {ex.Message}" }],
                IsError = true
            };
        }
    }

    private object CreateToolInputSchema(string commandName, Type commandType)
    {
        // Create a JSON schema for the command's input parameters
        // This is a simplified version - in a full implementation, we'd inspect the Settings class
        var schema = new
        {
            type = "object",
            description = $"Input parameters for {commandName} command",
            properties = new Dictionary<string, object>(),
            required = new List<string> { "file_path" }
        };

        // Add common parameters that most commands need
        schema.properties["file_path"] = new
        {
            type = "string",
            description = "The C# source file to refactor"
        };

        schema.properties["line_number"] = new
        {
            type = "integer",
            description = "Line number (1-based) where the refactoring should be applied",
            minimum = 1
        };

        schema.properties["column_number"] = new
        {
            type = "integer",
            description = "Column number (0-based) where the refactoring should be applied",
            minimum = 0
        };

        schema.properties["output_path"] = new
        {
            type = "string",
            description = "Output file path (optional, defaults to overwriting the input file)"
        };

        schema.properties["dry_run"] = new
        {
            type = "boolean",
            description = "Show what changes would be made without applying them"
        };

        // Add command-specific parameters based on command name
        AddCommandSpecificParameters(schema, commandName);

        return schema;
    }

    private void AddCommandSpecificParameters(dynamic schema, string commandName)
    {
        switch (commandName)
        {
            case "rename":
                schema.properties["old_name"] = new
                {
                    type = "string",
                    description = "Current name of the symbol to rename"
                };
                schema.properties["new_name"] = new
                {
                    type = "string", 
                    description = "New name for the symbol"
                };
                schema.required = new[] { "file_path", "old_name", "new_name" };
                break;
                
            case "extract-method":
                schema.properties["method_name"] = new
                {
                    type = "string",
                    description = "Name for the extracted method"
                };
                schema.properties["end_line_number"] = new
                {
                    type = "integer",
                    description = "End line number for the code selection to extract"
                };
                schema.required = new[] { "file_path", "method_name" };
                break;
                
            case "add-using":
                schema.properties["namespace"] = new
                {
                    type = "string",
                    description = "Namespace to add as a using statement"
                };
                schema.required = new[] { "file_path", "namespace" };
                break;
        }
    }

    private async Task<string> ExecuteCastCommandAsync(string commandName, Type commandType, JsonElement? arguments)
    {
        // Create a temporary CommandApp to execute the command
        var app = new CommandApp();
        
        // For now, simulate command execution
        // In a full implementation, we would properly invoke the command with parsed arguments
        var filePath = GetArgumentValue(arguments, "file_path");
        var dryRun = GetArgumentValue(arguments, "dry_run", false);
        
        if (string.IsNullOrEmpty(filePath))
        {
            return "Error: file_path is required";
        }

        if (!File.Exists(filePath))
        {
            return $"Error: File not found: {filePath}";
        }

        // For the initial implementation, return a success message
        // This would be replaced with actual command execution
        var result = $"Successfully executed {commandName} on {filePath}";
        if (dryRun)
        {
            result = $"[DRY RUN] Would execute {commandName} on {filePath}";
        }

        _logger.LogInformation($"Executed command {commandName}: {result}");
        return result;
    }

    private string GetArgumentValue(JsonElement? arguments, string key, string defaultValue = "")
    {
        if (arguments == null || !arguments.HasValue)
            return defaultValue;
            
        if (arguments.Value.TryGetProperty(key, out var property))
        {
            return property.GetString() ?? defaultValue;
        }
        
        return defaultValue;
    }

    private bool GetArgumentValue(JsonElement? arguments, string key, bool defaultValue)
    {
        if (arguments == null || !arguments.HasValue)
            return defaultValue;
            
        if (arguments.Value.TryGetProperty(key, out var property))
        {
            return property.GetBoolean();
        }
        
        return defaultValue;
    }

    private int GetArgumentValue(JsonElement? arguments, string key, int defaultValue)
    {
        if (arguments == null || !arguments.HasValue)
            return defaultValue;
            
        if (arguments.Value.TryGetProperty(key, out var property))
        {
            return property.GetInt32();
        }
        
        return defaultValue;
    }
}